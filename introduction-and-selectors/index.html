---
layout: presentation
theme: accent1
title: Introduction and Selectors
description: A brief introduction to CSS and an in-depth look at composing CSS selectors.
---

<section>
  <h1>CSS Power-ups</h1>
</section>

<section>
  <section>
    <p>Why get better at CSS?</p>
  </section>
  <section>
    <ul>
      <li>Consistent styles = better UX = <strong>more revenue</strong></li>
      <li class="fragment">More efficiency = more work done = <strong>more revenue</strong></li>
      <li class="fragment">Faster CSS = better UX = <strong>more revenue</strong></li>
    </ul>
    <aside class="notes">
      It's no surprise that your increased CSS knowledge will make you more efficient as you work in your CSS code. We are going to talk about how to keep styles consistent across browsers and how to write performant CSS in this course.
    </aside>
  </section>
  <section>
    <ul>
      <li>We're awesome and we are proud of our craft</li>
      <li class="fragment">CSS is a primary component of our tech stack</li>
      <li class="fragment">Writing CSS is <em>way</em> better now than it used to be</li>
    </ul>
    <aside class="notes">
      Every company's key to success is hiring top talentâ€”including engineers. We should write quality CSS because we are artisans, proud of our craft. If you are building web applications as part of a SaaS offering, CSS is a major component of your technology stack whether you like to admit it or not. Besides, it's a lot more fun to write now than it was even five years ago.
    </aside>
  </section>
</section>

<section>
  <section>
    <h2>Topics of this course</h2>
    <aside class="notes">
      I got the topics for this course from (1) the most common questions I get asked at work, (2) a survey I administered internally at Lucid Software last year to guage experience levels within the engineering organization (I then gave a tech talk on those topics and have re-used some of the material in that tech talk in this course), and (3) personal experience.
    </aside>
  </section>
  <section>
    <p>Selectors</p>
  </section>
  <section>
    <p>Specificity and the cascade</p>
  </section>
  <section>
    <p>The box model and positioning</p>
  </section>
  <section>
    <p>Property categories and CSS3 modules</p>
  </section>
  <section>
    <p>Responsive CSS</p>
  </section>
  <section>
    <p>CSS preprocessors</p>
  </section>
  <section>
    <p>Performance and Chrome's rendering cycle</p>
  </section>
  <section>
    <p>Frameworks and architecture paradigms</p>
    <aside class="notes">
      For Lucid Software's internal course, we are then going to talk about how it all relates to our codebase (the build process, the CSS directory, etc.).
    </aside>
  </section>
</section>

<section>
  <h1>Selectors</h1>
  <small>(<a href="http://www.w3.org/TR/selectors/">W3C Specification</a>)</small>
</section>

<section>
  <section>
    <p>CSS is in charge of all the visual styling of an HTML document.</p>
    <aside class="notes">
      CSS stands for Cascading Style Sheets.
      We'll talk about the "cascading" part of "CSS" next time.
    </aside>
  </section>
  <section>
    <p>It works by "targeting" specific HTML elements and applying styles to those elements.</p>
  </section>
  <section>
    <p>This "targeting" is achieved by <code>selectors</code>.</p>
  </section>
</section>

<section>
  <h2>Anatomy lesson</h2>
  <p>What is a selector?</p>
  <pre><code data-trim>
/* The "p" here is a selector. */
p {

  /* The declaration block is made up of property-value pairs. */
  color: red;

}
  </code></pre>
  <p>The whole thing is called a <em>rule</em>.</p>
</section>

<section>
  <section>
    <h3>Basic selectors</h3>
    <table class="small">
      <thead>
        <tr>
          <th>Selector type</th>
          <th>CSS</th>
          <th>English version</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Type</td>
          <td><code>p</code></td>
          <td>All paragraphs</td>
        </tr>
        <tr>
          <td>Class</td>
          <td><code>.warning</code></td>
          <td>Elements that have <code>warning</code> class</td>
        </tr>
        <tr>
          <td>ID</td>
          <td><code>#title</code></td>
          <td>Element that has ID of <code>title</code></td>
        </tr>
      </tbody>
    </table>
    <aside class="notes">
      Best practice: stick with classes for styling (we will get more into specificity next week). IDs are great for JS and Selenium, but not for CSS.
    </aside>
  </section>
  <section>
    <h3>Attribute selectors</h3>
    <table class="small">
      <thead>
        <tr>
          <th>CSS</th>
          <th>English</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>button[disabled]</code></td>
          <td>Buttons that have the <code>disabled</code> attribute</td>
        </tr>
        <tr>
          <td><code>input[type="text"]</code></td>
          <td>Inputs whose <code>type</code> attribute is equal to <code>text</code></td>
        </tr>
        <tr>
          <td><code>a[href*="wiki"]</code></td>
          <td>Inputs whose <code>href</code> attribute contains <code>wiki</code></td>
        </tr>
      </tbody>
    </table>
    <aside class="notes">
      There are others, but these are the most useful of the attribute selectors.
    </aside>
  </section>
  <section>
    <h3>Sequences of simple selectors</h3>
    <table class="small">
      <thead>
        <tr>
          <th>CSS</th>
          <th>English</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>h1#title</code></td>
          <td>The <code>h1</code> heading that has ID of <code>title</code></td>
        </tr>
        <tr>
          <td><code>p.intro.headline[style]</code></td>
          <td>Paragraphs that have both the <code>intro</code> and <code>headline</code> classes and that have a <code>style</code> attribute</td>
        </tr>
      </tbody>
    </table>
  </section>
  <section>
    <h3>Pseudo-classes</h3>
    <table class="small">
      <thead>
        <tr>
          <th>CSS</th>
          <th>English</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>:first-child</code></td>
          <td>Elements that are the first child of their parent</td>
        </tr>
        <tr>
          <td><code>:last-child</code></td>
          <td>Elements that are the last child of their parent</td>
        </tr>
        <tr>
          <td><code>:nth-child(3)</code></td>
          <td>Elements that are the third child of their parent</td>
        </tr>
        <tr>
          <td><code>:hover</code></td>
          <td>Elements that are currently under the mouse cursor</td>
        </tr>
        <tr>
          <td><code>:active</code></td>
          <td>Elements that are currently being clicked</td>
        </tr>
        <tr>
          <td><code>:empty</code></td>
          <td>Elements that have no children or text</td>
        </tr>
        <tr>
          <td><code>:not(.summary)</code></td>
          <td>Elements that do not have the <code>summary</code> class</td>
        </tr>
      </tbody>
    </table>
    <aside class="notes">
      An example use of the <code>:empty</code> pseudo-class would be on the Lucidpress document analytics page where a simple message is displayed to the user when there has not yet been any data collected for their document.
    </aside>
  </section>
  <section>
    <p>We're just scratching the surface...</p>
    <p>Find more selectors on <a href="http://www.w3.org/TR/selectors/#selectors">the W3C specification</a>.</p>
  </section>
</section>
<section>
  <section>
    <h2>Combinators</h2>
    <p>String together simple selectors (or sequences of simple selectors) with <em>combinators</em> to create super-charged selectors.</p>
  </section>
  <section>
    <table class="smaller">
      <thead>
        <tr>
          <th>Combinator type</th>
          <th>CSS</th>
          <th>English</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Descendant</td>
          <td><code>section li</code></td>
          <td>List items that are inside of sections</td>
        </tr>
        <tr>
          <td>Child</td>
          <td><code>p > a</code></td>
          <td>Anchor tags that are immediate children of paragraphs</td>
        </tr>
        <tr>
          <td>Adjacent sibling</td>
          <td><code>h1 + p</code></td>
          <td>Paragraphs immediately preceded by <code>h1</code> headings</td>
        </tr>
        <tr>
          <td>General sibling</td>
          <td><code>h1 ~ p</code></td>
          <td>Paragraphs preceded by <code>h1</code> headings</td>
        </tr>
      </tbody>
    </table>
    <aside class="notes">
      Despite intuition, the general sibling combinator only selects elements that appear after the specified elements.
    </aside>
  </section>
  <section>
    <pre><code class="css" data-trim>
.main header + section > .app.demo ul > li:first-child {
  /* List items that are the first children of unordered
   * lists that are descendants of elements with the "app"
   * and "demo" classes that are children of sections
   * preceded by headers that are descendants of elements
   * with the "main" class.
   */
}
    </code></pre>
    <aside class="notes">
      As you can see, you can use combinators to get very specific selectors. To reason through selectors like this, go from right to left. We'll talk more about specificity next week.
    </aside>
  </section>
</section>
